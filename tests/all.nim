import future
import random, random/urandom, random/mersenne
import distributions

# We initialize the random number generator
var rng = wrap(initMersenneTwister(urandom(16)))

proc sq(x: float): float = x * x

lift(sq)
# This is generated by the `lift` macro
#
# template sq(x: RandomVar[float]): auto =
#   map(x, sq)

# lift(`*`)
# Does not work yet
proc `*`(x, y: RandomVar[int]): auto =
  map2(x, y, (a: int, b: int) =>  a * b)

# We define a few distributions, both with the default
# constructors and using the operations above
let
  c = constant(3)
  u = uniform(2, 18)
  d = choose(@[1, 2, 3])
  t = d.map((x: int) => x * x)
  z = u.map((x: float) => x * x)
  s = sq(z)
  g = d * d
  w = t && d
  u1 = rng.discretize(u)

# Check that they are all random variables
echo(c is RandomVar[int])
echo(u is RandomVar[float])
echo(d is RandomVar[int])
echo(s is RandomVar[float])
echo(t is RandomVar[int])
echo(t is RandomVar)
# Sampling
echo rng.sample(c)
echo rng.sample(s)
echo rng.sample(t)
echo rng.sample(z)
echo rng.sample(w)
echo rng.sample(g)
echo rng.mean(s)
echo rng.mean(u)
echo rng.mean(u1)
# All this rng is repetitive: another macro would allow
# to use a common context, like this:
#
# withRng rng:
#   echo sample(c)
#   echo sample(s)
#   echo mean(s)
#
# Whenever a statement does not compile, try to add rng as first parameter